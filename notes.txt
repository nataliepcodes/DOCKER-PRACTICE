<=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=>
* [Docker Crash Course for Absolute Beginners by TechWorld with Nana]
(https://youtu.be/pg19Z8LL06w?si=pCpn_YpJH3JRUZc2)

What is Docker?
------------------------------------------------------------------------------------------
- virtualization software which simplifies the development and deployment of apps
- Docker packages into a container everything that the app needs to run it (e.g. runtime 
and environment configurations, dependencies, libraries etc)
- this package is portable and can be shared & distributed
------------------------------------------------------------------------------------------



What problems does Docker solve in the development and deployment processes?
------------------------------------------------------------------------------------------
Development process BEFORE: 
- all the app services had to be installed & configured directly on each developer's OS 
locally on their machine (e.g. db's, cache, messaging microservices, etc)
- installation process is OS / machine dependent (e.g. Mac OS, Linux etc) and there are 
many steps in installation processes with high chances that something could go wrong
- tedious process for setting up a development environment and can be very complex, 
depending on the app (e.g. if app has 10 services, each would need to be installed by 
each developer locally..)
Development process AFTER:
- with containers the developers do not need to install anything directly to their OS
- developers can start a specific service using 1 Docker command (e.g. docker run 
postgres, which would fetch the relevant package from the web and starts it on the 
developer's computer)
- there's one command that is the same for all Operating Systems and same command for 
all services
- so: if the app has 10 services, then the developer needs to run 10 commands (easy! :)
- Docker standardized the process of running any service on any local development 
environment
- easier and faster
- easier to run different version of the same app, with no conflicts

Deployment process BEFORE:
- Development team produced the application/artifact and its installation instructions 
(how to install & confure the app on the server) + if the db was used, then also 
instructions for how to install & configure the db, so that the app can use it
- Development team handed over the artifact and instructions to Ops team, who would 
handle the installation and config of apps & their dependencies
- Everything had to configured and installed directrly on the server's OS, which can be 
error-prone, potential dependency version conflicts
- miscommunication between dev and ops teams because instructions are written / textual - 
human errors, back and forth comms 

Deployment process AFTER:
- Developers create a package which already includes the code, and all the relevant 
dependencies and configurations
- No configurations are required on the server, except Docker runtime, which leaves 
less opportunities for errors and delays
- Ops team needs to install Docker runtime on the server - one time effort
- When artifacts received from the Development team, Ops team runs the Docker command 
which fetches and runs the relevant Docker artifacts
------------------------------------------------------------------------------------------



Virtual Machine vs Docker
------------------------------------------------------------------------------------------
OS has 2 layers:
1. OS application layer: runs on top of the kernel layer (e.g. Microsoft Word, 
Google Chrome, etc apps).
2. OS kernel layer: communicates with hardware components of the machine - 
e.g. CPU, storage
Kernel interacts between HW and SW components. Kernel is a core of every OS.

- Docker is the virtualization tool, next step / evolution from VMs
- Docker virtualizes the OS applications layer, container services and apps are 
on top of that layer. Doesn't have it's own kernel. Uses the kernel of the host.
- VM has both the OS application layer and OS kernel layer. It virtualizes a 
complete OS. If I download a VM image, it will not use the host kernel, it will 
have its own.
- Docker images/packages are much smaller, they implement only 1 layer of OS
- SIZE: Docker - MB size, VM - GB size
- SPEED: Docker in seconds to start, VM in minutes
- COMPATIBILITY: Docker only with Linux, VM compatible with all OS
- Linux based Docker image cannot use Windows kernel. Most containers are Linux 
based, originally built for Linux OS
- There's a Docker Desktop for Windows and Mac which makes possible to run Linux based 
containers on Windows or MacOS (uses Hypervisor layer..)
------------------------------------------------------------------------------------------



Install Docker
------------------------------------------------------------------------------------------
https://docs.docker.com/get-docker/



Docker Images vs Containers
------------------------------------------------------------------------------------------
- Docker image: executable application artifact (includes app source code, env configs, 
any services needed - e.g. node, npm for JS, environment variables, directories, files etc)
- Docker package is called an image
- Docker container: starts application in pre-configured environment, a running instance of 
the image; containers are run from images
- can run multiple containers from one image
------------------------------------------------------------------------------------------



Docker Registries
------------------------------------------------------------------------------------------
- storage and distribution system for Docker images available online, Docker hosts 
the biggest Docker Registry - Docker Hub - there I can find and share Docker images
- official images are available from various applications, e.g. Redis, Mongo, Postgres; 
and maintained by the software authors or Docker community
------------------------------------------------------------------------------------------



Docker Image Versions
------------------------------------------------------------------------------------------
- Docker images are versioned by image tags
- 'latest' is a special tag that all images have - means a latest release / 
latest built image
------------------------------------------------------------------------------------------



Practical:
------------------------------------------------------------------------------------------
-- Go to Docker Hub (via Google search)
-- Find Nginx image (Nginx is a simple webserver!)
-- Select a specific image tag -> version of image of Nginx
-- enter this command in the CLI -> $ docker pull nginx:1.25
------------------------------------------------------------------------------------------



Main Docker Commands - Pull and Run Docker containers
------------------------------------------------------------------------------------------
docker images = List all Docker images

docker ps = List running containers

docker pull {name}:{tag} = Pull an image from a Registry

docker pull {name} = Pull a LATEST image from a Registry

docker run {name}:{tag} = Creates a container from a given image and starts it

docker run -d or --detach {name}:{tag} = Runs container in the background and 
prints the container ID

docker logs {container ID} = View logs from service running inside the container
(which are present at the time of execution)

docker stop {container} = Stop one or more running containers

docker run -d -p {HOST_PORT}:{CONTAINER_PORT} {name}:{tag} = Publish container's port to the host (-p or --publish)

------------------------------------------------------------------------------------------



Port Binding - Container Port vs Host Port
------------------------------------------------------------------------------------------
-- an app inside the container runs in an isolated Docker network, on a specific port.
Apps have standard ports (e.g. nginx runs on port 80, redis runs on port 6379)
-- If I try to access the nginx port of the container on the browser (localhost:80), 
it will not work!! It doesn't!
-- I need to xpose the container's port (e.g. nginx port 80) to the local host port 
(the machine the container runs on - this case, my machine :D ), any specific port.
-- Port binding: binding the container's port to the host's port to make the 
service available to the "outside world" 

e.g.:
$ docker run -d -p 9000:80 nginx:1.25

Test, if it works: http://localhost:9000/ ( it works!! :D so cool!) 

Note: only 1 service can run on a specific port on the host port at the same time
( 1 service on port 9000)

I can choose any local host port, although it is standard to use the same port as the 
container is using. E.g. if MySQL is on port 3306, then localhost to be 3306 also


------------------------------------------------------------------------------------------



Start and Stop containers
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Private Docker Registries
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Registry vs Repository
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Dockerfile - Dockerize Node.js app
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Build Image
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Docker UI Client
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Overview: Docker in complete software development lifecycle
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------



Where to go from here
------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------

<=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=><=>